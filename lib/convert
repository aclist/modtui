#!/usr/bin/env bash
tool=modTUI
version=0.2.0
from_dirs(){
	local name="$1"
	local path="$2"
	local outfile="$modtui_path/$1.json"
	local state="enabled"
	local type="mod"
	readarray -t d < <(find "$path"/* -maxdepth 0 -type d)
	readarray -t mods < <(for((i=0;i<${#d[@]};i++)); do basename "${d[$i]}"; done)
	masthead "$outfile"
	for (( i = 0; i < ${#mods[@]}; i++ )); do
		tput sc
		printf  "[INFO] Preparing record %i of %i" $((i+1)) ${#mods[@]}
		dir="${mods[$i]}"
		name=$(<<< "$dir" sed 's/_/ /g')
		d=$(munge "$name" "$type" "$state" "$dir")
		add_mod "$outfile" "$d"
		if [[ $i -eq $((${#mods[@]}-1)) ]]; then
			printf "\n[INFO] Wrote modlist to '%s'\n" "$outfile"
			return 0
		fi
		tput rc
		tput el
		
	done
}
add_into(){
	local config="$1"
	local modpath="$3"
	readarray -t mods <<< "$2"
	for (( i = 0; i < ${#mods[@]}; i++ )); do
		dir=${mods[$i]}
		name=$(<<< "$dir" sed 's/_/ /g')
		if [[ -z $(ls -A "$modpath/$dir") ]]; then
			logger WARN "New mod '$dir' is empty, adding as empty" loud
			state="empty"
		else
			logger INFO "New mod '$dir' is present, starting disabled" loud
			state="disabled"
		fi
		d=$(munge "$name" "mod" "$state" "$dir")
		add_mod "${modtui_path}/$config.json" "$d"
	done
	unset mods
}
update_into(){
	local config="$1"
	local modpath="$3"
	readarray -t mods <<< "$2"
	for((i=0;i<${#mods[@]};i++)); do
		dir="${mods[$i]}"
		if [[ -d "$modpath/$dir" ]]; then
			state=disabled
			if [[ -z $(ls -A "$dir") ]]; then
				state=empty
			fi
		else
			continue
		fi
	done
	echo STATE $state
	echo NAME "$name"
	unset mods
}
add_mod(){
	local outfile="$1"
	local d="$2"
	< "$outfile" jq -r --argjson d "$d" '.mods+=[$d]' >> $outfile.new &&
		mv $outfile.new $outfile
}
masthead(){
	jq --null-input --arg tool $tool --arg vers $version '
			{"meta":{"tool":$tool,
			"version":$vers,
			"date":now|strflocaltime("%s")
			},
			"mods":[]}
			' > "$1"
}
munge(){
	jq --null-input \
		--arg name "$1" \
		--arg type "$2" \
		--arg state "$3" \
		--arg dir "$4" '
		{"name":$name,
		"type":$type,
		"state":$state,
		"dir": $dir,
		"author":"",
		"entry_point": [],
		"dl_url": "",
		"human_url": "",
		"notes": ""
		}'
}
jsonify(){
	outfile=modlist.json
	flip=$(tac "$1" | awk 'NF' | grep -v '^#' | sed 's/^\(.\)\([0-9]\+- \)/\1/g')
	readarray -t state < <(<<< "$flip" awk '!/^#/ {print substr($0,1,1)}')
	mods=$(<<< "$flip" sed 's/^.//g')
	readarray -t name <<< "$mods"
	masthead "$outfile"
	file=$(basename -- "$1")
	for (( i = 0; i < ${#state[@]}; i++ )); do
		tput sc
		printf  "[INFO] Converting record %i of %i" $((i+1)) ${#state[@]}
		if [[ "${name[$i]}" =~ _separator$ ]]; then
			name=$(<<< "${name[$i]}" awk -F'_separator' '{print $1}')
			type=separator
			d=$(jq --null-input \
				--arg name "$name" \
				--arg type "$type" \
				--arg state "$state" '
				{"name":$name,
				"type":$type,
				}'
			)
		else
			dir="${name[$i]}"
			name=$(<<< "$dir" sed 's/_/ /g')
			type=mod
			case "${state[$i]}" in
				+) state=enabled ;;
				-) state=disabled ;;
			esac
			d=$(munge "$name" "$type" "$state" "$dir")
		fi
		add_mod "$outfile" "$d"
		if [[ $i -eq $((${#state[@]}-1)) ]]; then
			printf "\n[INFO] Converted '%s' to '%s'\n" "$1" "$outfile"
			return 0
		fi
		tput rc
		tput el
	done
	tput cnorm
}
txtify(){
	outfile=modlist.txt
	infile="$1"
	gen(){
		< "$infile" jq -r '
		.mods[]|"\(if .state == "enabled" then "+" else "-" end)"+
		"\(if .type == "separator" then .name+"_separator" else .name end)"'
		echo "#Generated by $tool $version"
	}
	gen "$infile" > $outfile
	echo "Converted $1 to $outfile"
}
cleanup(){
	tput cnorm
	logger INFO "User exit" loud
	exit
}
convert(){
	[[ -z "$1" ]] && { logger ERROR "Must specify an input file" loud; exit 1; }
	[[ ! -f "$1" ]] && { logger ERROR "Not a valid filepath" loud; exit 1; }
	local file="$1"
	local mime=$(file -i "$file" | awk '{print $2}' | sed 's/;$//')
	local base=$(basename -- "$file")
	local ext=${base##*.}
	if [[ $ext == "json" ]]; then
		jq type "$file" 1>/dev/null 2>/dev/null
		[[ ! $? -eq 0 ]] && { logger ERROR "Not valid JSON data" loud; return 1; }
	fi
	case "$mime" in
		text/plain) jsonify "$file" ;;
		application/json) txtify "$file" ;;
		*) logger ERROR "Supported mimetypes: text/plain, application/json" loud; exit 1
	esac
}
trap cleanup SIGINT INT
"$@"
